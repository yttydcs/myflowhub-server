《基于树形网络结构的个人物联网平台权限控制设计理念总结》

本设计基于个人物联网（IoT）场景的树形拓扑，目标是在保证各层自治的前提下提供安全、可控、可验证的权限体系。核心思想如下：

### 1. 树形自治管理

- 父节点对其子树拥有绝对控制权，是该子树唯一的策略制定者。
- 子节点对父节点指令绝对信任，仅作为执行点（PEP），不重复校验权限。
- 局部管理权天然绑定在父子关系中，实现层级自治并降低全局同步开销。

### 2. 请求上行、自然到达 LCA

- 当目标不在本地子树时，节点将请求原样上报父节点；父节点重复同样的判断。
- 由于“能处理就处理、不能处理就上报”的链路，决策最终落在最近公共祖先（LCA），无需显式计算 LCA。
- LCA 依据 RBAC 策略决定允许或拒绝，保证最小授权域治理并避免根节点过载。

### 3. 请求链与控制链分离

- **请求链（向上）**：节点仅能选择提前拒绝或继续上报，不做细粒度判断。
- **控制链（向下）**：当授权通过后，由 LCA 下发控制指令，沿树形逐级转发到目标节点，所有下行节点只负责可靠送达。
- 这种分离确保决策层与执行层职责清晰，避免重复判权。

### 4. 身份与令牌绑定权限

- 每个主体持有独立公私钥；私钥保留在主体本地，公钥注册到授权中心。
- 授权中心签发携带角色、权限范围（scope）与有效期的 RBAC Token，并用其私钥签名。
- 主体发起请求时用私钥签名，LCA 需验证：令牌是否可信、签名与公钥是否匹配、RBAC 是否允许该操作。
- 因此父节点无法伪装子节点，权限不再依赖拓扑位置，同一主体可被授予多个子树的 scope。

### 5. 权限节点与判定逻辑

- 将敏感 action 归一化为权限节点 ID（`协议.action`），例如登录撤销对应 `auth.revoke`，写私有变量可定义为 `var.private_set`。
- 节点的角色绑定一组权限节点列表：当收到需要授权的 action 时，检查发起节点角色是否包含该权限节点即可得出结论。
- 所有需要权限的 action 默认上报父节点处理：若当前节点能确认目标资源在本子树并具备策略，则就地判权与执行；否则继续上报，直到具备处理能力。
- 授权结果统一通过对应的 `xxxConResp` 返回，无论成功、拒绝还是异常，响应都沿原链路下行到发起节点。

### 6. 行为分类与可扩展策略

- 将 action 分为“需要权限”和“无需权限”两类。前者走上述上报链路，后者可由本地直接处理。
- 需要权限的 action 列表可通过配置维护（如 `required_permissions = ["auth.revoke", "var.private_set"]`），便于后续扩展。
- 可配置“即使能处理也上报父节点”，以支持集中审计或统一策略场景。

### 7. 五句话概括

1. 控制权沿树形结构向上集中、沿结构向下分发，父节点对子树拥有绝对管辖能力。
2. 请求沿父链上报，天然在最近公共祖先完成判权，实现最小授权域的治理。
3. 请求链只判断是否上报或拒绝，控制链只负责执行，保证层次清晰且高效。
4. 主体权限绑定在密钥身份与授权令牌上，而非拓扑位置，避免父节点伪装子节点。
5. RBAC 角色与权限节点映射提供统一的判权接口，所有授权结果通过规范的 `xxxConResp` 返回。

### 8. 与 flow/exec 的结合（补充）

- `flow.set` 属于需要权限的 action（权限节点：`flow.set`）：请求应先发送给直接父节点并逐级上报，直到某一层能确认执行者在其子树内并具备策略，从而完成判权与响应；执行者仅在允许后才落盘生效。
- `exec.call` 属于需要权限的 action（权限节点：`exec.call`）：当目标节点不在本地可控的子树方向时，按同样的“逐级上报”到最近公共祖先裁决并向下转发；当目标节点位于本地的 downstream（父→子可控方向）时，可直接向下发送（子节点信任父节点）。
